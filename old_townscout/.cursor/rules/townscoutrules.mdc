---
description: 
globs: 
alwaysApply: true
---
TownScout Web Dashboard

1) Mission & Scope

Mission: Build an interactive, stackable-filter map that answers: “Where should I live given my criteria?” It must feel instant, cost pennies, and scale nationwide.

MVP Scope (must ship):
	•	US map with H3 hex layers at two resolutions (r7, r8).
	•	Precomputed “minutes-to-nearest” integers for a few POI categories (start: Chipotle, Costco; later: hospitals, airports).
	•	Client-side filtering in MapLibre; no live routing.
	•	Export tiles as PMTiles and serve from static hosting/CDN.
	•	Optional tiny API for ranking cities/ZIPs (Redis-backed set intersections).

Non-Goals (for now):
	•	Live traffic, turn-by-turn routing, or per-request Google/Places calls.
	•	Full base map styling; our colored hex layer is enough.
	•	Friend/family proximity or user-uploaded POIs (post-MVP).

⸻

2) Architecture (authoritative)

Data → Compute → Tiles → UI
	1.	Data: OSM Geofabrik PBFs + brand name filters (no Overpass at runtime).
	2.	Compute: Build drivable graph from PBF (Pyrosm → OSMnx). For each brand:
	•	Snap POIs → multi-source Dijkstra on travel_time (sec) → aggregate to H3.
	•	Store integers (minutes, ceil) per cell per metric. No floats.
	3.	Tiles: Merge per-state parquet → GeoJSON → MBTiles (tippecanoe) → PMTiles.
	4.	UI: MapLibre GL loads PMTiles; filter expressions drive instant updates.
	5.	API (optional): FastAPI + Redis intersections to rank cities/ZIPs at thresholds.

Why this matters: Sliders change style filters only. No backend work per interaction. Costs stay near zero. Scale is a CDN problem, not a server problem.

⸻

3) Product Requirements (MVP acceptance)
	•	Map loads two vector tile sources: us_r7 (zoom <8) and us_r8 (zoom ≥8).
	•	Two sliders:
	•	chipotle_drive_min (5–45, step=5)
	•	costco_drive_min (5–60, step=5)
	•	Filter = ["all", ["<=", ["coalesce", ["get","chipotle_drive_min"], 9999], X], ["<=", ["coalesce", ["get","costco_drive_min"], 9999], Y]]
	•	Tooltip or side label (optional): ✅/❌ per criterion on hover.
	•	Nudge logic when filter yields zero visible hexes (“Try +5–10 minutes”).
	•	Share button copies URL with current slider params.
	•	Tiles render within <250ms after slider move on a 2020 laptop.
	•	Output files present:
	•	tiles/us_r7.pmtiles, tiles/us_r8.pmtiles
	•	Optional CSVs for Pro export: state_tiles/us_r7.csv, us_r8.csv

⸻

4) Data Pipeline Requirements
	•	Inputs: data/osm/{state}.osm.pbf
	•	POI extraction: Pyrosm with brand/name filters (name/brand/operator), case-insensitive.
	•	Routing: OSMnx add_edge_speeds + add_edge_travel_times (free-flow).
	•	Graph flood: networkx.multi_source_dijkstra_path_length using travel_time.
	•	H3 aggregation: h3.latlng_to_cell(lat, lon, res), min per cell.
	•	Resolutions: H3_RES_LOW=7, H3_RES_HIGH=8.
	•	Columns: one integer column per metric: chipotle_drive_min, costco_drive_min, etc.
	•	Merge contract: per-state parquet → outer-merge on h3 → us_r{res}.parquet.
	•	Tiles: tippecanoe to MBTiles (layer names must equal source IDs) → convert to PMTiles.
	•	Delta recompute: Given a (state, brand, action, lat, lon) CSV, recompute only H3 rings around changed POIs and take min with existing minutes for add/move. (Close is future work.)

⸻

5) Tech Stack & Commands
	•	Python 3.11, libs: pandas, geopandas, shapely, pyproj, rtree, pyrosm, osmnx, networkx, h3, pyarrow, tqdm.
	•	CLIs: tippecanoe, pmtiles.
	•	Frontend: MapLibre + pmtiles JS.
	•	API (optional): FastAPI, Redis.

Make targets (must exist):
	•	make pbf → download PBFs
	•	make pois → extract brand POIs
	•	make minutes → compute per-state minutes
	•	make merge → produce state_tiles/us_r7.parquet & us_r8.parquet
	•	make geojson → export GeoJSON
	•	make tiles → MBTiles → PMTiles
	•	make all → full pipeline

Local serve:
	•	python -m http.server 5173 from repo root; open /tiles/web/index.html.

⸻

6) Directory & File Contract

data/osm/             # *.osm.pbf
data/poi/             # {state}_{brand}.parquet
data/minutes/         # {state}_r{res}.parquet
data/deltas/          # poi_delta.csv (state,brand,action,lat,lon)
state_tiles/          # us_r{res}.parquet (+ optional CSV)
tiles/                # us_r{res}.geojson, .mbtiles, .pmtiles
tiles/web/            # index.html, style.css
src/                  # scripts & modules (see below)

Source modules (keep names stable):
config.py, util_osm.py, util_h3.py, util_tiles.py, 01_download_osm_extracts.py, 02_extract_pois_from_pbf.py, 03_compute_minutes_per_state.py, 03a_parallel_driver.py, 03b_delta_recompute.py, 04_merge_states.py, 05_h3_to_geojson.py, 06_build_tiles.py, 07_export_csv.py, api/main.py.

⸻

7) Coding Rules for Cursor
	•	Never add floats to tile properties. Integers only (minutes).
	•	Do not call external APIs (Google/Foursquare/Overpass) in runtime code. Use local PBFs.
	•	Keep tile property names stable. Changing them breaks the frontend filter.
	•	Don’t create new layers per metric. One layer with multiple properties; filter via style expressions.
	•	Keep binaries small: only include the metrics we use. No debug props in tiles.
	•	Idempotent scripts: each step should be safe to rerun; use exist_ok and skip if outputs exist.
	•	Parallelism: Only in 03a_parallel_driver.py across states; avoid per-state thread storms.
	•	Licensing: Add “Map data © OpenStreetMap contributors” in UI footer. Never embed paid/API data in tiles.

⸻

8) Performance Targets & Budgets
	•	Initial tile download (warmed CDN): ≤10–50 MB per session.
	•	Slider update to render: ≤250ms.
	•	Tile size: Keep combined PMTiles (r7 + r8, two metrics) under 400 MB.
	•	Compute time: Single-state run ≤10 minutes on a 8-core laptop; nationwide is a batch job.

⸻

9) QA & Acceptance Checks
	•	Data sanity: In dense metros, *_drive_min should be single digits; in rural, tens. No negative/NaN in tiles.
	•	Filtering: Moving either slider monotonically never increases visible area when lowering thresholds.
	•	Zero-result nudge: If no visible features after filter, show nudge text.
	•	Deep link: URL reflects current sliders (e.g., ?chipotle=15&costco=20) and loads same state on refresh.
	•	Tile integrity: pmtiles info tiles/us_r7.pmtiles reports layer=us_r7. Same for r8.

⸻

10) Security & Privacy
	•	Entire MVP can ship as static assets. No user auth required.
	•	If API is enabled: CORS * for MVP, no PII stored. Redis only stores set membership for H3 cells.
	•	No client secrets in code. PMTiles are public.

⸻

11) Extensibility (next iterations Cursor can scaffold)
	•	Add hospitals_drive_min, airports_drive_min using same pipeline.
	•	Add rank endpoint that accepts arbitrary thresholds and returns top N cities by score.
	•	Add CSV export gated by an environment flag for Pro.

⸻

12) “Cursor Tasks” (ready-to-run prompts)

Task A — Build data pipeline scaffolding
	•	Create modules and scripts named exactly as in §6.
	•	Implement Makefile targets that call each script with python (env will alias to python3).
	•	Each script logs start/finish and writes outputs to the contracted paths.

Task B — Implement MapLibre frontend
	•	tiles/web/index.html renders sliders, loads PMTiles via pmtiles protocol, adds two layers (layer_r7, layer_r8) with zoom ranges, and applies the filter expression from §3.
	•	Add share button that writes URL params and reads them at load.

Task C — Delta recompute
	•	Implement 03b_delta_recompute.py to recompute only affected H3 rings for (state, brand, lat, lon) rows; update parquet in place; then rebuild merged and tiles.

Task D — Optional API
	•	src/api/main.py with /health and /rank?chipotle=..&costco=..&limit=... Use Redis set names ts:{metric}:{threshold}. Return JSON rows with name, state, zip, score.

⸻

13) Environment Prereqs (macOS dev)
	•	Install: brew install python@3.11 proj geos gdal tippecanoe pmtiles jq
	•	Python: python -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt
	•	Serve: python -m http.server 5173 from repo root.

⸻

14) Definition of Done (MVP)
	•	make all produces PMTiles and CSVs without errors.
	•	Opening /tiles/web/index.html shows colored hexes; sliders filter instantly.
	•	Share URL persists filter state.
	•	OSM attribution visible.
	•	README includes run/deploy steps and cost notes.