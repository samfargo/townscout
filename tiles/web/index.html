<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TownScout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <!-- Use pmtiles.js for protocol -->
  <script src="/tiles/web/pmtiles.js"></script>
  <style>
    body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    .panel { position: absolute; top: 16px; left: 16px; background: #fff; padding: 14px 16px; border-radius: 10px; z-index: 1; box-shadow: 0 6px 20px rgba(0,0,0,0.12); width: 320px; }
    .panel h3 { margin: 0 0 12px; font-size: 16px; font-weight: 600; color: #1f2937; }
    .row { display: flex; align-items: center; margin-bottom: 10px; gap: 10px; }
    .row label { flex: 1; font-size: 13px; color: #374151; }
    .row input[type="range"] { flex: 1.6; }
    .row span { font-weight: 600; width: 36px; text-align: right; color: #111827; }
    .row select { flex: 1; padding: 6px 8px; border: 1px solid #e5e7eb; border-radius: 8px; background: #f9fafb; color: #111827; font-size: 13px; }
    .row select:focus { outline: none; border-color: #93c5fd; box-shadow: 0 0 0 3px rgba(59,130,246,0.25); }
    .filter-row { align-items: center; }
    .filter-row .spacer { flex: 0.2; }
    .pins-toggle { display: inline-flex; align-items: center; gap: 4px; font-size: 12px; color: #374151; }
    .pins-toggle input { cursor: pointer; }
    .remove-btn { background: transparent; border: none; color: #6b7280; cursor: pointer; padding: 4px 6px; border-radius: 6px; font-size: 13px; }
    .remove-btn:hover { background: #f3f4f6; color: #111827; }
    .status { margin-top: 10px; font-size: 12px; }
    .nudge { font-size: 12px; color: #666; background: #eee; padding: 5px; border-radius: 3px; display: none; }
    .footer { position: absolute; bottom: 5px; right: 10px; font-size: 11px; background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px; z-index: 1; }
    .hover-box { position: absolute; top: 10px; right: 10px; background: #fff; padding: 10px 12px; border-radius: 6px; z-index: 2; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 220px; max-width: 280px; pointer-events: none; }
    .hover-box h4 { margin: 0 0 8px; font-size: 14px; font-weight: 600; }
    .hover-box .kv { display: flex; justify-content: space-between; font-size: 13px; margin: 4px 0; }
    .hover-box .muted { color: #666; font-size: 12px; }
    .towns-box { position: absolute; top: 120px; right: 10px; background: #fff; padding: 10px 12px; border-radius: 6px; z-index: 2; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 240px; max-width: 300px; pointer-events: auto; }
    .towns-box h4 { margin: 0 0 8px; font-size: 14px; font-weight: 600; }
    .towns-box ul { margin: 0; padding-left: 18px; max-height: 220px; overflow: auto; }
    .towns-box .muted { color: #666; font-size: 12px; }
  </style>
</head>
<body>
<div class="panel">
  <h3>TownScout Criteria</h3>
  <div id="filters">
    <div class="row filter-row">
      <label>Mode</label>
      <select id="mode-select">
        <option value="drive" selected>Drive</option>
        <option value="walk">Walk</option>
      </select>
      <span class="spacer"></span>
    </div>
    <!-- POI selector + dynamic sliders -->
    <div class="row filter-row">
      <label for="poi-select">Add POI</label>
      <select id="poi-select"></select>
      <button id="add-poi" class="remove-btn" title="Add selected POI">Add</button>
      <button id="add-custom" class="remove-btn" title="Pick a custom location on the map">Custom</button>
    </div>
    <div id="filter-rows"></div>
  </div>
  <div id="nudge" class="nudge">Try increasing minutes to see more areas.</div>
  <button id="share" style="width: 100%; margin-top: 10px; padding: 5px;">Share Map</button>
</div>

<div id="map"></div>

<div id="hover-box" class="hover-box">
  <h4>Travel Time (minutes)</h4>
  <div id="hover-content" class="muted">Move cursor over a hex</div>
</div>

<div class="footer">
  Map data © OpenStreetMap contributors
</div>

<script>
  // ---------- PMTiles Protocol ----------
  let protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  const R7_DRIVE_URL = "pmtiles:///tiles/t_hex_r7_drive.pmtiles";
  const R8_DRIVE_URL = "pmtiles:///tiles/t_hex_r8_drive.pmtiles";
  const R8_WALK_URL  = "pmtiles:///tiles/t_hex_r8_walk.pmtiles";
  const R7_DRIVE_HTTP = R7_DRIVE_URL.replace(/^pmtiles:\/\//, '');
  const R8_DRIVE_HTTP = R8_DRIVE_URL.replace(/^pmtiles:\/\//, '');
  const R8_WALK_HTTP  = R8_WALK_URL.replace(/^pmtiles:\/\//, '');

  const map = new maplibregl.Map({
    container: 'map',
    style: {
      version: 8,
      sources: {
        'osm': {
          type: 'raster',
          tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
          tileSize: 256,
          attribution: '© OpenStreetMap contributors'
        },
        'us_r7_drive': {
          type: 'vector',
          url: R7_DRIVE_URL,
          attribution: "TownScout"
        },
        'us_r8_drive': {
          type: 'vector',
          url: R8_DRIVE_URL
        },
        'us_r8_walk': {
          type: 'vector',
          url: R8_WALK_URL
        }
      },
      layers: [
        { id: 'osm-base', type: 'raster', source: 'osm', paint: { 'raster-opacity': 0.7 } },
        {
          id: 'layer_r7_drive',
          type: 'fill',
          source: 'us_r7_drive',
          'source-layer': 't_hex_r7_drive',
          maxzoom: 9.5,
          paint: {
            'fill-color': '#1976d2',
            'fill-opacity': ['interpolate', ['linear'], ['zoom'], 7, 0.5, 9, 0.3],
            'fill-outline-color': 'rgba(0, 0, 0, 0.1)'
          }
        },
        {
          id: 'layer_r8_drive',
          type: 'fill',
          source: 'us_r8_drive',
          'source-layer': 't_hex_r8_drive',
          minzoom: 7.5,
          paint: {
            'fill-color': '#1976d2',
            'fill-opacity': ['interpolate', ['linear'], ['zoom'], 7.5, 0, 9, 0.5],
            'fill-outline-color': 'rgba(0, 0, 0, 0.1)'
          }
        },
        {
          id: 'layer_r8_walk',
          type: 'fill',
          source: 'us_r8_walk',
          'source-layer': 't_hex_r8_walk',
          minzoom: 8,
          layout: { 'visibility': 'none' },
          paint: {
            'fill-color': '#10b981',
            'fill-opacity': 0.5,
            'fill-outline-color': 'rgba(0, 0, 0, 0.1)'
          }
        }
      ]
    },
    center: [-98.58, 39.83], // US center
    zoom: 4
  });

  // ---------- Hover Box ----------
  function updateHoverBox(feature) {
    const contentEl = document.getElementById('hover-content');
    // In anchor mode, the mousemove handler renders hover content;
    // for no-feature cases or non-anchor fallback, show a simple hint.
    contentEl.innerHTML = '<span class="muted">Move cursor over a hex</span>';
  }
  
  // ---------- Filter Logic ----------
  // ---------- Dynamic POI Filters (Anchor Mode Only) ----------
  // Anchor-mode required: we compose a{i}_s with D_anchor maps from the API
  let ANCHOR_MODE = true; // anchor arrays present; compose with D_anchor
  let CURRENT_MODE = 'drive'; // 'drive' | 'walk'
  const MAX_K = 20; // align with tiles: support up to 20 anchors; missing ones coalesce to sentinel
  const dAnchorCache = {}; // { categoryId|brandId: { anchorId: seconds } }

  const selectedPOIs = [];
  const activePins = {}; // rowKey -> { brands: string[], sourceId: string, layerIds: string[] }
  let PICKING_CUSTOM = false;

  // (min-cols fallback removed)

  function buildMinExprForCategory(catId) {
    // Compose min over top-K anchors: a{i}_s + D_anchor[a{i}_id]
    const catMap = dAnchorCache[catId] || {};
    const literalMap = ["literal", catMap];
    const UNREACHABLE = 65535;
    const terms = [];
    for (let i = 0; i < MAX_K; i++) {
      const aSec = ["coalesce", ["get", `a${i}_s`], UNREACHABLE];
      const aidStr = ["to-string", ["get", `a${i}_id`]];
      const catSec = ["coalesce", ["get", aidStr, literalMap], UNREACHABLE];
      terms.push(["+", aSec, catSec]);
    }
    return ["min", ...terms];
  }

  function buildMinExprForBrand(brandId) {
    // Like category: min over a{i}_s + D_anchor_brand[a{i}_id]
    const brandMap = dAnchorCache[brandId] || {};
    const literalMap = ["literal", brandMap];
    const UNREACHABLE = 65535;
    const terms = [];
    for (let i = 0; i < MAX_K; i++) {
      const aSec = ["coalesce", ["get", `a${i}_s`], UNREACHABLE];
      const aidStr = ["to-string", ["get", `a${i}_id`]];
      const bSec = ["coalesce", ["get", aidStr, literalMap], UNREACHABLE];
      terms.push(["+", aSec, bSec]);
    }
    return ["min", ...terms];
  }

  function buildFilterExpressionCombined() {
    const clauses = ["all"];
    selectedPOIs.forEach((p) => {
      const slider = document.getElementById(`slider_${p.id}`);
      if (!slider) return;
      if (p.type === 'category') {
        if (dAnchorCache[p.id] && Object.keys(dAnchorCache[p.id]).length > 0) {
          const maxMin = parseInt(slider.value, 10) * 60; // seconds
          const minExpr = buildMinExprForCategory(p.id);
          clauses.push(["<=", minExpr, maxMin]);
        }
      } else if (p.type === 'brand') {
        if (dAnchorCache[p.id] && Object.keys(dAnchorCache[p.id]).length > 0) {
          const maxMin = parseInt(slider.value, 10) * 60; // seconds
          const minExpr = buildMinExprForBrand(p.id);
          clauses.push(["<=", minExpr, maxMin]);
        }
      } else if (p.type === 'custom') {
        if (dAnchorCache[p.id] && Object.keys(dAnchorCache[p.id]).length > 0) {
          const maxMin = parseInt(slider.value, 10) * 60; // seconds
          const minExpr = buildMinExprForBrand(p.id);
          clauses.push(["<=", minExpr, maxMin]);
        }
      }
    });
    return clauses;
  }

  function updateMapFilter() {
    // Update inline value bubbles
    selectedPOIs.forEach((poi) => {
      const slider = document.getElementById(`slider_${poi.id}`);
      const valSpan = document.getElementById(`val_${poi.id}`);
      if (slider && valSpan) valSpan.textContent = slider.value;
    });
    // If no POIs selected, show all hexes (no filter)
    const filter = selectedPOIs.length > 0 ? buildFilterExpressionCombined() : null;
    // Apply to current mode layer(s)
    if (CURRENT_MODE === 'drive') {
      map.setFilter('layer_r8_drive', filter);
      map.setFilter('layer_r7_drive', filter);
      map.setFilter('layer_r8_walk', null);
    } else {
      map.setFilter('layer_r8_walk', filter);
      map.setFilter('layer_r8_drive', null);
      map.setFilter('layer_r7_drive', null);
    }
  }

  function debounce(fn, ms) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), ms);
    };
  }
  
  const debouncedUpdate = debounce(updateMapFilter, 50);

  function addPOIRow(poi) {
    // Avoid duplicates
    if (selectedPOIs.find(p => p.id === poi.id && p.type === poi.type)) return;
    selectedPOIs.push(poi);
    const container = document.getElementById('filter-rows');
    const row = document.createElement('div');
    row.className = 'row';
    row.id = `row_${poi.type}_${poi.id}`;
    row.innerHTML = `
      <label for="slider_${poi.id}">${poi.label} (minutes)</label>
      <input id="slider_${poi.id}" type="range" min="${poi.min}" max="${poi.max}" step="${poi.step}" value="${poi.def}">
      <span id="val_${poi.id}">${poi.def}</span>
      <label class="pins-toggle" title="Show pins for ${poi.label}"><input id="pins_${poi.type}_${poi.id}" type="checkbox"> Pins</label>
      <button class="remove-btn" id="rm_${poi.id}" title="Remove ${poi.label}">✕</button>
    `;
    container.appendChild(row);
    document.getElementById(`slider_${poi.id}`).addEventListener('input', debouncedUpdate);
    const pinsEl = document.getElementById(`pins_${poi.type}_${poi.id}`);
    if (pinsEl) {
      pinsEl.addEventListener('change', async (e) => {
        await togglePinsForPoi(poi, e.target.checked);
      });
    }
    document.getElementById(`rm_${poi.id}`).addEventListener('click', () => {
      // Remove from selected list and DOM
      const idx = selectedPOIs.findIndex(p => p.id === poi.id && p.type === poi.type);
      if (idx >= 0) selectedPOIs.splice(idx, 1);
      row.remove();
      removePinsForPoi(poi);
      updateMapFilter();
    });
    if (poi.type === 'custom') {
      fetchDAnchorCustom(poi.lon, poi.lat).then(() => updateMapFilter());
    } else if (ANCHOR_MODE && poi.type === 'category') {
      fetchDAnchor(poi.id).then(() => updateMapFilter());
    } else {
      updateMapFilter();
    }
  }

  async function fetchJSON(url) {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return resp.json();
  }

  // (tile metadata probing and fallback removed)

  // (fallback selector removed)

  function initPoiSelector() {
    initCatalogSelector().catch(() => {
      const select = document.getElementById('poi-select');
      select.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Catalog unavailable';
      select.appendChild(opt);
    });
  }

  // ---------- Catalog + Anchor Mode ----------
  async function fetchDAnchor(categoryId) {
    if (dAnchorCache[categoryId]) return dAnchorCache[categoryId];
    const data = await fetchJSON(`/api/d_anchor?category=${encodeURIComponent(categoryId)}&mode=${encodeURIComponent(CURRENT_MODE)}`);
    dAnchorCache[categoryId] = data;
    return data;
  }

  async function initCatalogSelector() {
    const resp = await fetchJSON(`/api/catalog?mode=${encodeURIComponent(CURRENT_MODE)}`);
    const categories = Array.isArray(resp.categories) ? resp.categories : [];
    const brands = Array.isArray(resp.brands) ? resp.brands : [];
    const catToBrands = resp.cat_to_brands || {};
    ANCHOR_MODE = true; // always anchor-mode; D_anchor fetched on demand
    // Stash for URL parsing and labels
    window._categoriesById = new Map(categories.map(c => [String(c.id), c.label]));
    window._brandLabelById = new Map(brands.map(b => [String(b.id), b.label]));
    window._catToBrands = catToBrands;
    populateCatalogSelector(categories, brands, catToBrands);
  }

  // ---------- Custom D_anchor ----------
  function customKeyForLonLat(lon, lat) {
    const lonf = Number(lon).toFixed(5);
    const latf = Number(lat).toFixed(5);
    return `custom@${lonf},${latf}`;
  }

  async function fetchDAnchorCustom(lon, lat) {
    const key = customKeyForLonLat(lon, lat);
    if (dAnchorCache[key]) return dAnchorCache[key];
    const params = new URLSearchParams();
    params.set('lon', String(lon));
    params.set('lat', String(lat));
    params.set('mode', CURRENT_MODE);
    const data = await fetchJSON(`/api/d_anchor_custom?${params.toString()}`);
    dAnchorCache[key] = data;
    return data;
  }

  // (min-column fallback removed; GPU composition only)

  function populateCatalogSelector(categories, brands, catToBrands) {
    const select = document.getElementById('poi-select');
    select.innerHTML = '';
    const brandMap = new Map(brands.map(b => [String(b.id), b.label]));
    // Group categories by label to avoid repeated labels (e.g., multiple "Restaurant")
    const groups = new Map(); // label -> { label, ids:Set<string>, brandIds:Set<string> }
    categories.forEach(cat => {
      const label = String(cat.label);
      const scid = String(cat.id);
      const g = groups.get(label) || { label, ids: new Set(), brandIds: new Set() };
      g.ids.add(scid);
      const bidList = catToBrands[String(cat.id)] || [];
      bidList.forEach(bid => g.brandIds.add(String(bid)));
      groups.set(label, g);
    });

    // Stash mapping of joined-ids -> label for URL parsing
    window._groupLabelByIds = new Map();

    const addedBrands = new Set();
    Array.from(groups.values()).sort((a,b) => a.label.localeCompare(b.label)).forEach(g => {
      const og = document.createElement('optgroup');
      og.label = g.label;
      // Category-level selection (joined ids)
      const joined = Array.from(g.ids).sort().join(',');
      const optAll = document.createElement('option');
      optAll.value = `cat:${joined}`;
      optAll.textContent = g.label;
      og.appendChild(optAll);
      window._groupLabelByIds.set(joined, g.label);
      // Brand list (union across grouped categories)
      Array.from(g.brandIds).sort().forEach(bid => {
        const opt = document.createElement('option');
        opt.value = `brand:${bid}`;
        opt.textContent = brandMap.get(bid) || bid;
        og.appendChild(opt);
        addedBrands.add(bid);
      });
      select.appendChild(og);
    });

    // Add any extra brands (no category mapping) under Other Brands
    const extra = brands.filter(b => !addedBrands.has(String(b.id)));
    if (extra.length) {
      const og = document.createElement('optgroup');
      og.label = 'Other Brands';
      extra.forEach(b => {
        const opt = document.createElement('option');
        opt.value = `brand:${b.id}`;
        opt.textContent = b.label;
        og.appendChild(opt);
      });
      select.appendChild(og);
    }
    const addBtn = document.getElementById('add-poi');
    addBtn.onclick = async () => {
      const v = select.value || '';
      if (v.startsWith('cat:')) {
        const id = v.slice(4); // may be comma-joined ids
        const label = (window._groupLabelByIds && window._groupLabelByIds.get(String(id))) || (window._categoriesById && window._categoriesById.get(String(id))) || `Category ${id}`;
        const ids = String(id).split(',').filter(Boolean);
        addPOIRow({ type: 'category', id, ids, label, def: 30, min: 5, max: 240, step: 5 });
        await ensureCombinedDAnchor(id, ids);
        updateMapFilter();
      } else if (v.startsWith('brand:')) {
        const id = v.slice(6);
        const label = brandMap.get(id) || (window._brandLabelById && window._brandLabelById.get(id)) || id;
        addPOIRow({ type: 'brand', id, label, def: 30, min: 5, max: 240, step: 5 });
        try { await fetchDAnchorBrand(id); } catch (e) {}
        updateMapFilter();
      }
    };
  }

  async function ensureCombinedDAnchor(key, ids) {
    // Ensure dAnchorCache[key] contains per-anchor seconds = min over ids' maps
    if (!Array.isArray(ids)) ids = String(key).split(',').filter(Boolean);
    // Fetch missing pieces
    await Promise.all(ids.map((cid) => dAnchorCache[cid] ? Promise.resolve(dAnchorCache[cid]) : fetchDAnchor(cid)));
    const combined = {};
    ids.forEach((cid) => {
      const m = dAnchorCache[cid] || {};
      for (const [aid, sec] of Object.entries(m)) {
        const v = combined[aid];
        combined[aid] = (v == null) ? sec : Math.min(v, sec);
      }
    });
    dAnchorCache[key] = combined;
    return combined;
  }

  async function fetchDAnchorBrand(brandId) {
    if (dAnchorCache[brandId]) return dAnchorCache[brandId];
    const data = await fetchJSON(`/api/d_anchor_brand?brand=${encodeURIComponent(brandId)}&mode=${encodeURIComponent(CURRENT_MODE)}`);
    dAnchorCache[brandId] = data;
    return data;
  }

  // ---------- Pins (POI locations) ----------
  function rowKeyForPoi(poi) {
    return `${poi.type}_${poi.id}`;
  }

  function getBrandIdsForPoi(poi) {
    if (poi.type === 'brand') return [String(poi.id)];
    const mapping = window._catToBrands || {};
    const ids = Array.isArray(poi.ids) ? poi.ids : String(poi.id).split(',').filter(Boolean);
    const out = new Set();
    ids.forEach((cid) => {
      const arr = mapping[String(cid)] || [];
      arr.forEach((b) => out.add(String(b)));
    });
    return Array.from(out);
  }

  function currentBboxParam() {
    try {
      const b = map.getBounds();
      return `${b.getWest()},${b.getSouth()},${b.getEast()},${b.getNorth()}`;
    } catch (e) {
      return null;
    }
  }

  async function fetchPinsGeoJSON(brands) {
    const params = new URLSearchParams();
    params.set('brands', brands.join(','));
    const bbox = currentBboxParam();
    if (bbox) params.set('bbox', bbox);
    return await fetchJSON(`/api/poi_points?${params.toString()}`);
  }

  function removePinsForPoi(poi) {
    const key = rowKeyForPoi(poi);
    const rec = activePins[key];
    if (!rec) return;
    // Remove layers first, then source
    try { if (map.getLayer(rec.layerIds[2])) map.removeLayer(rec.layerIds[2]); } catch (e) {}
    try { if (map.getLayer(rec.layerIds[1])) map.removeLayer(rec.layerIds[1]); } catch (e) {}
    try { if (map.getLayer(rec.layerIds[0])) map.removeLayer(rec.layerIds[0]); } catch (e) {}
    try { if (map.getSource(rec.sourceId)) map.removeSource(rec.sourceId); } catch (e) {}
    delete activePins[key];
  }

  async function togglePinsForPoi(poi, checked) {
    const key = rowKeyForPoi(poi);
    if (!checked) {
      removePinsForPoi(poi);
      return;
    }
    if (poi.type === 'custom') {
      // Add a single-point source + simple circle layer
      const sourceId = `pins_${key}`;
      const layerId = `pins_${key}_point`;
      try { if (map.getLayer(layerId)) map.removeLayer(layerId); } catch (e) {}
      try { if (map.getSource(sourceId)) map.removeSource(sourceId); } catch (e) {}
      const geo = { type: 'FeatureCollection', features: [ { type: 'Feature', geometry: { type: 'Point', coordinates: [poi.lon, poi.lat] }, properties: {} } ] };
      map.addSource(sourceId, { type: 'geojson', data: geo });
      map.addLayer({ id: layerId, type: 'circle', source: sourceId, paint: { 'circle-radius': 6, 'circle-color': '#ef4444', 'circle-stroke-color': '#ffffff', 'circle-stroke-width': 1.2 } });
      activePins[key] = { brands: [], sourceId, layerIds: [layerId] };
      return;
    }
    const brands = getBrandIdsForPoi(poi);
    if (!brands || brands.length === 0) {
      // No known brands under this selection
      return;
    }
    const geo = await fetchPinsGeoJSON(brands);
    const sourceId = `pins_${key}`;
    const unclusterId = `pins_${key}_points`;
    const clusterId = `pins_${key}_clusters`;
    const clusterCountId = `pins_${key}_count`;
    // Clean any stale layers/sources
    try { if (map.getLayer(clusterCountId)) map.removeLayer(clusterCountId); } catch(e) {}
    try { if (map.getLayer(clusterId)) map.removeLayer(clusterId); } catch(e) {}
    try { if (map.getLayer(unclusterId)) map.removeLayer(unclusterId); } catch(e) {}
    try { if (map.getSource(sourceId)) map.removeSource(sourceId); } catch(e) {}

    map.addSource(sourceId, { type: 'geojson', data: geo, cluster: true, clusterRadius: 40, clusterMaxZoom: 14 });
    // Unclustered points
    map.addLayer({
      id: unclusterId,
      type: 'circle',
      source: sourceId,
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, 2.5, 10, 4, 14, 6],
        'circle-color': '#8b5cf6',
        'circle-opacity': 0.85,
        'circle-stroke-color': '#ffffff',
        'circle-stroke-width': 0.8
      }
    });
    // Cluster circles
    map.addLayer({
      id: clusterId,
      type: 'circle',
      source: sourceId,
      filter: ['has', 'point_count'],
      paint: {
        'circle-radius': ['step', ['get', 'point_count'], 12, 25, 16, 50, 20],
        'circle-color': '#8b5cf6',
        'circle-opacity': 0.6
      }
    });
    // Cluster counts
    map.addLayer({
      id: clusterCountId,
      type: 'symbol',
      source: sourceId,
      filter: ['has', 'point_count'],
      layout: {
        'text-field': ['get', 'point_count_abbreviated'],
        'text-size': 12
      },
      paint: { 'text-color': '#ffffff' }
    });

    activePins[key] = { brands, sourceId, layerIds: [unclusterId, clusterId, clusterCountId] };
  }

  async function refreshActivePins() {
    const keys = Object.keys(activePins);
    if (!keys.length) return;
    for (const key of keys) {
      const rec = activePins[key];
      try {
        const geo = await fetchPinsGeoJSON(rec.brands);
        const src = map.getSource(rec.sourceId);
        if (src && src.setData) src.setData(geo);
      } catch (e) {
        // ignore transient errors
      }
    }
  }

  // ---------- Share URL ----------
  document.getElementById('share').addEventListener('click', () => {
    const params = new URLSearchParams();
    // Mode
    params.set('mode', CURRENT_MODE);
    // Categories
    const cats = selectedPOIs.filter(p => p.type === 'category').map(p => {
      const slider = document.getElementById('slider_' + p.id);
      const v = slider ? slider.value : p.def;
      return `${encodeURIComponent(p.id)}:${v}`;
    });
    if (cats.length) params.set('cat', cats.join(','));
    // Brands
    const brands = selectedPOIs.filter(p => p.type === 'brand').map(p => {
      const slider = document.getElementById('slider_' + p.id);
      const v = slider ? slider.value : p.def;
      return `${encodeURIComponent(p.id)}:${v}`;
    });
    if (brands.length) params.set('brand', brands.join(','));
    // Custom
    const customs = selectedPOIs.filter(p => p.type === 'custom').map(p => {
      const slider = document.getElementById('slider_' + p.id);
      const v = slider ? slider.value : p.def;
      const lon = Number(p.lon).toFixed(5);
      const lat = Number(p.lat).toFixed(5);
      return `${encodeURIComponent(lon + '|' + lat)}:${v}`;
    });
    if (customs.length) params.set('custom', customs.join(','));
    const url = new URL(window.location.href);
    url.search = params.toString();
    navigator.clipboard.writeText(url.toString()).then(() => {
      const btn = document.getElementById('share');
      const originalText = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(() => (btn.textContent = originalText), 1500);
    });
  });

  async function applyUrlParams() {
    const params = new URLSearchParams(window.location.search);
    // Mode
    const m = params.get('mode');
    if (m === 'walk' || m === 'drive') {
      CURRENT_MODE = m;
      document.getElementById('mode-select').value = m;
      // Toggle layers now if already loaded
      try {
        if (ANCHOR_MODE) {
          map.setLayoutProperty('layer_r8_drive', 'visibility', m === 'drive' ? 'visible' : 'none');
          map.setLayoutProperty('layer_r8_walk', 'visibility', m === 'walk' ? 'visible' : 'none');
          map.setLayoutProperty('layer_r7_drive', 'visibility', 'none');
        }
      } catch (e) {}
    }
    // Categories
    if (params.has('cat')) {
      const pairs = params.get('cat').split(',');
      for (const item of pairs) {
        const [idEnc, val] = item.split(':');
        const id = decodeURIComponent(idEnc);
        const ids = String(id).split(',').filter(Boolean);
        const label = (window._groupLabelByIds && window._groupLabelByIds.get(String(id))) || (ids.length === 1 ? (window._categoriesById && window._categoriesById.get(String(id))) : null) || `Category ${id}`;
        addPOIRow({ type: 'category', id, ids, label, def: 30, min: 5, max: 240, step: 5 });
        const slider = document.getElementById(`slider_${id}`);
        if (slider && val) slider.value = val;
        await ensureCombinedDAnchor(id, ids);
      }
    }
    // Brands
    if (params.has('brand')) {
      const pairs = params.get('brand').split(',');
      for (const item of pairs) {
        const [idEnc, val] = item.split(':');
        const id = decodeURIComponent(idEnc);
        const label = (window._brandLabelById && window._brandLabelById.get(id)) || id.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        addPOIRow({ type: 'brand', id, label, def: 30, min: 5, max: 240, step: 5 });
        const slider = document.getElementById(`slider_${id}`);
        if (slider && val) slider.value = val;
        try { await fetchDAnchorBrand(id); } catch (e) {}
      }
    }
    // Custom
    if (params.has('custom')) {
      const pairs = params.get('custom').split(',');
      for (const item of pairs) {
        const [coordEnc, val] = item.split(':');
        const coord = decodeURIComponent(coordEnc);
        const [lonS, latS] = coord.split('|');
        const lon = parseFloat(lonS);
        const lat = parseFloat(latS);
        const id = customKeyForLonLat(lon, lat);
        addPOIRow({ type: 'custom', id, label: 'Custom Location', lon, lat, def: 30, min: 5, max: 240, step: 5 });
        const slider = document.getElementById(`slider_${id}`);
        if (slider && val) slider.value = val;
        try { await fetchDAnchorCustom(lon, lat); } catch (e) {}
      }
    }
    if (selectedPOIs.length === 0) {
      // Default: none preselected; user picks from dropdown
    }
  }

  // ---------- Mode Toggle ----------
  function setLayerVisibility(id, vis) {
    try {
      if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
    } catch (e) {}
  }

  function setMode(mode) {
    if (CURRENT_MODE === mode) return;
    CURRENT_MODE = mode;
    // Toggle layers
    if (ANCHOR_MODE) {
      setLayerVisibility('layer_r7_drive', 'none');
      setLayerVisibility('layer_r8_drive', mode === 'drive' ? 'visible' : 'none');
      setLayerVisibility('layer_r8_walk', mode === 'walk' ? 'visible' : 'none');
    }
    // Reset caches and refetch D_anchor for selected categories
    for (const k in dAnchorCache) delete dAnchorCache[k];
    if (ANCHOR_MODE) {
      initCatalogSelector();
      const loaders = selectedPOIs.map(p => p.type === 'category' ? fetchDAnchor(p.id) : fetchDAnchorBrand(p.id));
      Promise.all(loaders).then(() => updateMapFilter());
    } else {
      updateMapFilter();
    }
    // No tile-column fallback; catalog remains the source of truth
  }

  document.getElementById('mode-select').addEventListener('change', (e) => {
    setMode(e.target.value);
  });

  // ---------- Map Events ----------
  map.on('load', async () => {
    initPoiSelector();
    // Wait a tick for metadata to resolve and selector to populate (anchor vs min mode)
    setTimeout(async () => {
      await applyUrlParams();
      updateMapFilter();
    }, 50);

    map.on('mousemove', (e) => {
      const layers = ['layer_r8_drive', 'layer_r8_walk', 'layer_r7_drive'];
      const features = map.queryRenderedFeatures(e.point, { layers });
      if (features && features.length > 0) {
        const f = features[0];
        if (ANCHOR_MODE) {
          // Build hover details for selected categories and brands
          const props = f.properties || {};
          let html = '';
          selectedPOIs.forEach((p) => {
            if (p.type === 'category') {
              const UNREACH = 65535;
              let minsSec = UNREACH;
              for (let i = 0; i < MAX_K; i++) {
                const aSec = (props[`a${i}_s`] ?? UNREACH);
                const aid = String(props[`a${i}_id`] ?? '');
                const catMap = dAnchorCache[p.id] || {};
                const catSec = (aid && catMap[aid] != null) ? catMap[aid] : UNREACH;
                const tot = aSec + catSec;
                if (tot < minsSec) minsSec = tot;
              }
              const mins = (minsSec >= UNREACH) ? 'N/A' : Math.ceil(minsSec / 60) + ' min';
              html += `<div class="kv"><span>${p.label}</span><span>${mins}</span></div>`;
            } else if (p.type === 'brand') {
              const UNREACH = 65535;
              let minsSec = UNREACH;
              for (let i = 0; i < MAX_K; i++) {
                const aSec = (props[`a${i}_s`] ?? UNREACH);
                const aid = String(props[`a${i}_id`] ?? '');
                const brandMap = dAnchorCache[p.id] || {};
                const bSec = (aid && brandMap[aid] != null) ? brandMap[aid] : UNREACH;
                const tot = aSec + bSec;
                if (tot < minsSec) minsSec = tot;
              }
              const mins = (minsSec >= UNREACH) ? 'N/A' : Math.ceil(minsSec / 60) + ' min';
              html += `<div class="kv"><span>${p.label}</span><span>${mins}</span></div>`;
            }
          });
          document.getElementById('hover-content').innerHTML = html || '<span class="muted">Select a category or brand</span>';
        } else {
          updateHoverBox(f);
        }
      } else {
        updateHoverBox(null);
      }
    });
    map.on('moveend', refreshActivePins);

    // Enable map-pick for custom location
    document.getElementById('add-custom').addEventListener('click', () => {
      PICKING_CUSTOM = true;
      const btn = document.getElementById('add-custom');
      const original = btn.textContent;
      btn.textContent = 'Click map…';
      const once = async (e) => {
        if (!PICKING_CUSTOM) return;
        PICKING_CUSTOM = false;
        btn.textContent = original;
        try {
          const lngLat = e.lngLat || (e.point && map.unproject(e.point));
          const lon = lngLat.lng;
          const lat = lngLat.lat;
          const id = customKeyForLonLat(lon, lat);
          addPOIRow({ type: 'custom', id, label: 'Custom Location', lon, lat, def: 30, min: 5, max: 240, step: 5 });
          await fetchDAnchorCustom(lon, lat);
          updateMapFilter();
        } finally {
          map.off('click', once);
        }
      };
      map.once('click', once);
    });
  });

</script>
</body>
</html>
