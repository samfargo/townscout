<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TownScout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <!-- Use pmtiles.js for protocol -->
  <script src="/tiles/web/pmtiles.js"></script>
  <style>
    body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    .panel { position: absolute; top: 16px; left: 16px; background: #fff; padding: 14px 16px; border-radius: 10px; z-index: 1; box-shadow: 0 6px 20px rgba(0,0,0,0.12); width: 320px; }
    .panel h3 { margin: 0 0 12px; font-size: 16px; font-weight: 600; color: #1f2937; }
    .search-container { margin-bottom: 16px; }
    .search-container label { display: block; font-size: 13px; color: #374151; margin-bottom: 6px; }
    .search-box { position: relative; }
    .search-input { width: 100%; padding: 8px 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 14px; transition: border-color 0.15s ease, box-shadow 0.15s ease; }
    .search-input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.2); }
    .search-results { position: absolute; top: calc(100% + 4px); left: 0; right: 0; background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; box-shadow: 0 10px 24px rgba(15, 23, 42, 0.15); max-height: 260px; overflow-y: auto; z-index: 20; padding: 4px 0; display: none; }
    .search-results.open { display: block; }
    .search-item { padding: 8px 12px; cursor: pointer; }
    .search-item:hover, .search-item.active { background: #eff6ff; }
    .search-primary { font-size: 14px; font-weight: 600; color: #111827; }
    .search-secondary { font-size: 12px; color: #6b7280; margin-top: 2px; }
    .search-status { margin-top: 6px; font-size: 12px; color: #6b7280; min-height: 16px; }
    .search-status.error { color: #dc2626; }
    .search-status.info { color: #2563eb; }
    .row { display: flex; align-items: center; margin-bottom: 10px; gap: 10px; }
    .row label { flex: 1; font-size: 13px; color: #374151; }
    .row input[type="range"] { flex: 1.6; }
    .row span { font-weight: 600; width: 36px; text-align: right; color: #111827; }
    .row select { flex: 1; padding: 6px 8px; border: 1px solid #e5e7eb; border-radius: 8px; background: #f9fafb; color: #111827; font-size: 13px; }
    .row select:focus { outline: none; border-color: #93c5fd; box-shadow: 0 0 0 3px rgba(59,130,246,0.25); }
    .filter-row { align-items: center; }
    .filter-row .spacer { flex: 0.2; }
    .pins-toggle { display: inline-flex; align-items: center; gap: 4px; font-size: 12px; color: #374151; }
    .pins-toggle input { cursor: pointer; }
    .remove-btn { background: transparent; border: none; color: #6b7280; cursor: pointer; padding: 4px 6px; border-radius: 6px; font-size: 13px; }
    .remove-btn:hover { background: #f3f4f6; color: #111827; }
    .status { margin-top: 10px; font-size: 12px; }
    .nudge { font-size: 12px; color: #666; background: #eee; padding: 5px; border-radius: 3px; display: none; }
    .footer { position: absolute; bottom: 5px; right: 10px; font-size: 11px; background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px; z-index: 1; }
    .hover-box { position: absolute; top: 10px; right: 10px; background: #fff; padding: 10px 12px; border-radius: 6px; z-index: 2; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 220px; max-width: 280px; pointer-events: none; }
    .hover-box h4 { margin: 0 0 8px; font-size: 14px; font-weight: 600; }
    .hover-box .kv { display: flex; justify-content: space-between; font-size: 13px; margin: 4px 0; }
    .hover-box .muted { color: #666; font-size: 12px; }
    .towns-box { position: absolute; top: 120px; right: 10px; background: #fff; padding: 10px 12px; border-radius: 6px; z-index: 2; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 240px; max-width: 300px; pointer-events: auto; }
    .towns-box h4 { margin: 0 0 8px; font-size: 14px; font-weight: 600; }
    .towns-box ul { margin: 0; padding-left: 18px; max-height: 220px; overflow: auto; }
    .towns-box .muted { color: #666; font-size: 12px; }
    .loading-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 9999; display: none; align-items: center; justify-content: center; }
    .loading-overlay.active { display: flex; }
    .loading-box { background: white; padding: 24px 32px; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.3); text-align: center; }
    .loading-spinner { width: 40px; height: 40px; border: 4px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.8s linear infinite; margin: 0 auto 16px; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
<div class="panel">
  <h3>TownScout Criteria</h3>
  <div class="search-container">
    <label for="place-search-input">Search for a custom location</label>
    <div class="search-box">
      <input id="place-search-input" class="search-input" type="text" placeholder="Search for an address or place" autocomplete="off" aria-autocomplete="list" aria-controls="place-search-results" aria-expanded="false" />
      <div id="place-search-results" class="search-results" role="listbox"></div>
    </div>
    <div id="place-search-status" class="search-status"></div>
  </div>
  <div id="filters">
    <div class="row filter-row">
      <label>Mode</label>
      <select id="mode-select">
        <option value="drive" selected>Drive</option>
        <option value="walk">Walk</option>
      </select>
      <span class="spacer"></span>
    </div>
    <!-- POI selector + dynamic sliders -->
    <div class="row filter-row">
      <label for="poi-select">Add POI</label>
      <select id="poi-select"></select>
      <button id="add-poi" class="remove-btn" title="Add selected POI">Add</button>
      <button id="add-custom" class="remove-btn" title="Pick a custom location on the map">Custom</button>
    </div>
    <div id="filter-rows"></div>
  </div>
  <div id="nudge" class="nudge">Try increasing minutes to see more areas.</div>
  <button id="share" style="width: 100%; margin-top: 10px; padding: 5px;">Share Map</button>
</div>

<div id="map"></div>

<div id="hover-box" class="hover-box">
  <h4>Travel Time (minutes)</h4>
  <div id="hover-content" class="muted">Move cursor over a hex</div>
</div>

<div id="loading-overlay" class="loading-overlay">
  <div class="loading-box">
    <div class="loading-spinner"></div>
    <div id="loading-text" style="font-size: 14px; color: #374151;">Computing drive times...</div>
  </div>
</div>

<div class="footer">
  Map data © OpenStreetMap contributors
</div>

<script>
  // ---------- PMTiles Protocol ----------
  let protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  const R7_DRIVE_URL = "pmtiles:///tiles/t_hex_r7_drive.pmtiles";
  const R8_DRIVE_URL = "pmtiles:///tiles/t_hex_r8_drive.pmtiles";
  const R8_WALK_URL  = "pmtiles:///tiles/t_hex_r8_walk.pmtiles";
  const R7_DRIVE_HTTP = R7_DRIVE_URL.replace(/^pmtiles:\/\//, '');
  const R8_DRIVE_HTTP = R8_DRIVE_URL.replace(/^pmtiles:\/\//, '');
  const R8_WALK_HTTP  = R8_WALK_URL.replace(/^pmtiles:\/\//, '');

  const map = new maplibregl.Map({
    container: 'map',
    style: {
      version: 8,
      sources: {
        'osm': {
          type: 'raster',
          tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
          tileSize: 256,
          attribution: '© OpenStreetMap contributors'
        },
        'us_r7_drive': {
          type: 'vector',
          url: R7_DRIVE_URL,
          attribution: "TownScout"
        },
        'us_r8_drive': {
          type: 'vector',
          url: R8_DRIVE_URL
        },
        'us_r8_walk': {
          type: 'vector',
          url: R8_WALK_URL
        }
      },
      layers: [
        { id: 'osm-base', type: 'raster', source: 'osm', paint: { 'raster-opacity': 0.7 } },
        {
          id: 'layer_r7_drive',
          type: 'fill',
          source: 'us_r7_drive',
          'source-layer': 't_hex_r7_drive',
          maxzoom: 9.5,
          paint: {
            'fill-color': '#1976d2',
            'fill-opacity': ['interpolate', ['linear'], ['zoom'], 7, 0.5, 9, 0.3],
            'fill-outline-color': 'rgba(0, 0, 0, 0.1)'
          }
        },
        {
          id: 'layer_r8_drive',
          type: 'fill',
          source: 'us_r8_drive',
          'source-layer': 't_hex_r8_drive',
          minzoom: 7.5,
          paint: {
            'fill-color': '#1976d2',
            'fill-opacity': ['interpolate', ['linear'], ['zoom'], 7.5, 0, 9, 0.5],
            'fill-outline-color': 'rgba(0, 0, 0, 0.1)'
          }
        },
        {
          id: 'layer_r8_walk',
          type: 'fill',
          source: 'us_r8_walk',
          'source-layer': 't_hex_r8_walk',
          minzoom: 8,
          layout: { 'visibility': 'none' },
          paint: {
            'fill-color': '#10b981',
            'fill-opacity': 0.5,
            'fill-outline-color': 'rgba(0, 0, 0, 0.1)'
          }
        }
      ]
    },
    center: [-98.58, 39.83], // US center
    zoom: 4
  });

  // ---------- Hover Box ----------
  function updateHoverBox(feature) {
    const contentEl = document.getElementById('hover-content');
    // In anchor mode, the mousemove handler renders hover content;
    // for no-feature cases or non-anchor fallback, show a simple hint.
    contentEl.innerHTML = '<span class="muted">Move cursor over a hex</span>';
  }
  
  // ---------- Filter Logic ----------
  // ---------- Dynamic POI Filters (Anchor Mode Only) ----------
  // Anchor-mode required: we compose a{i}_s with D_anchor maps from the API
  let ANCHOR_MODE = true; // anchor arrays present; compose with D_anchor
  let CURRENT_MODE = 'drive'; // 'drive' | 'walk'
  const MAX_K = 20; // align with tiles: support up to 20 anchors; missing ones coalesce to sentinel
  const dAnchorCache = {}; // { categoryId|brandId|customKey: { anchorId: seconds } }
  const customCoverageMinutes = {}; // { customKey: max minutes covered }
  const CUSTOM_MIN_MINUTES = 5;
  const CUSTOM_MAX_MINUTES = 240;
  const CUSTOM_FETCH_GRANULARITY = 5; // Fetch custom D_anchor in 5-minute increments

  const PLACE_AUTOCOMPLETE_MIN_CHARS = 2;
  const PLACE_AUTOCOMPLETE_DEBOUNCE_MS = 200;
  const PLACE_SUGGESTION_LIMIT = 8;
  let placeSearchSessionToken = null;
  let placeSearchAbortController = null;
  let placeSearchSuggestions = [];
  let placeSearchActiveIndex = -1;
  let placeSearchInputEl = null;
  let placeSearchResultsEl = null;
  let placeSearchStatusEl = null;
  let placeSearchMarker = null;

  const selectedPOIs = [];
  const activePins = {}; // rowKey -> { brands: string[], sourceId: string, layerIds: string[] }
  let PICKING_CUSTOM = false;

  function showLoading(text = 'Computing drive times...') {
    const overlay = document.getElementById('loading-overlay');
    const textEl = document.getElementById('loading-text');
    if (textEl) textEl.textContent = text;
    if (overlay) overlay.classList.add('active');
  }

  function hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) overlay.classList.remove('active');
  }

  // (min-cols fallback removed)

  function buildMinExprForCategory(catId) {
    // Compose min over top-K anchors: a{i}_s + D_anchor[a{i}_id]
    const catMap = dAnchorCache[catId] || {};
    const literalMap = ["literal", catMap];
    const UNREACHABLE = 65535;
    const terms = [];
    for (let i = 0; i < MAX_K; i++) {
      const aSec = ["coalesce", ["get", `a${i}_s`], UNREACHABLE];
      const aidStr = ["to-string", ["get", `a${i}_id`]];
      const catSec = ["coalesce", ["get", aidStr, literalMap], UNREACHABLE];
      terms.push(["+", aSec, catSec]);
    }
    return ["min", ...terms];
  }

  function buildMinExprForBrand(brandId) {
    // Like category: min over a{i}_s + D_anchor_brand[a{i}_id]
    const brandMap = dAnchorCache[brandId] || {};
    const literalMap = ["literal", brandMap];
    const UNREACHABLE = 65535;
    const terms = [];
    for (let i = 0; i < MAX_K; i++) {
      const aSec = ["coalesce", ["get", `a${i}_s`], UNREACHABLE];
      const aidStr = ["to-string", ["get", `a${i}_id`]];
      const bSec = ["coalesce", ["get", aidStr, literalMap], UNREACHABLE];
      terms.push(["+", aSec, bSec]);
    }
    return ["min", ...terms];
  }

  function buildMinExprForCustom(customId) {
    // Same as brand: min over a{i}_s + D_anchor_custom[a{i}_id]
    const customMap = dAnchorCache[customId] || {};
    const literalMap = ["literal", customMap];
    const UNREACHABLE = 65535;
    const terms = [];
    for (let i = 0; i < MAX_K; i++) {
      const aSec = ["coalesce", ["get", `a${i}_s`], UNREACHABLE];
      const aidStr = ["to-string", ["get", `a${i}_id`]];
      const cSec = ["coalesce", ["get", aidStr, literalMap], UNREACHABLE];
      terms.push(["+", aSec, cSec]);
    }
    return ["min", ...terms];
  }

  function buildFilterExpressionCombined() {
    const clauses = ["all"];
    selectedPOIs.forEach((p) => {
      const slider = document.getElementById(`slider_${p.id}`);
      if (!slider) return;
      if (p.type === 'category') {
        if (dAnchorCache[p.id] && Object.keys(dAnchorCache[p.id]).length > 0) {
          const maxMin = parseInt(slider.value, 10) * 60; // seconds
          const minExpr = buildMinExprForCategory(p.id);
          clauses.push(["<=", minExpr, maxMin]);
        }
      } else if (p.type === 'brand') {
        if (dAnchorCache[p.id] && Object.keys(dAnchorCache[p.id]).length > 0) {
          const maxMin = parseInt(slider.value, 10) * 60; // seconds
          const minExpr = buildMinExprForBrand(p.id);
          clauses.push(["<=", minExpr, maxMin]);
        }
      } else if (p.type === 'custom') {
        const cacheEntry = dAnchorCache[p.id];
        const entrySize = cacheEntry ? Object.keys(cacheEntry).length : 0;
        console.log(`Custom POI ${p.id}: cache has ${entrySize} entries, slider=${slider.value}min`);
        if (cacheEntry && entrySize > 0) {
          const maxMin = parseInt(slider.value, 10) * 60; // seconds
          const minExpr = buildMinExprForCustom(p.id);
          clauses.push(["<=", minExpr, maxMin]);
        } else {
          console.warn(`Custom POI ${p.id}: no cache data available yet`);
        }
      }
    });
    console.log(`Filter expression has ${clauses.length - 1} clauses`);
    return clauses;
  }

  async function updateMapFilter() {
    // Update inline value bubbles
    selectedPOIs.forEach((poi) => {
      const slider = document.getElementById(`slider_${poi.id}`);
      const valSpan = document.getElementById(`val_${poi.id}`);
      if (slider && valSpan) valSpan.textContent = slider.value;
    });

    // Ensure custom POIs have coverage for the current slider minutes before filtering
    const pending = [];
    selectedPOIs.forEach((poi) => {
      if (poi.type !== 'custom') return;
      const slider = document.getElementById(`slider_${poi.id}`);
      if (!slider) return;
      const minutes = normalizeMinutes(slider.value);
      const covered = customCoverageMinutes[poi.id] || 0;
      if (covered >= minutes) return;
      pending.push(fetchDAnchorCustom(poi.lon, poi.lat, minutes));
    });
    if (pending.length > 0) {
      try {
        await Promise.all(pending);
      } catch (err) {
        console.error('Failed to refresh custom D_anchor coverage', err);
      }
    }

    // If no POIs selected, show all hexes (no filter)
    const filter = selectedPOIs.length > 0 ? buildFilterExpressionCombined() : null;
    // Apply to current mode layer(s)
    if (CURRENT_MODE === 'drive') {
      map.setFilter('layer_r8_drive', filter);
      map.setFilter('layer_r7_drive', filter);
      map.setFilter('layer_r8_walk', null);
    } else {
      map.setFilter('layer_r8_walk', filter);
      map.setFilter('layer_r8_drive', null);
      map.setFilter('layer_r7_drive', null);
    }
  }

  function debounce(fn, ms) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), ms);
    };
  }
  
  const debouncedUpdate = debounce(updateMapFilter, 50);

  function addPOIRow(poi) {
    const existingIdx = selectedPOIs.findIndex(p => p.id === poi.id && p.type === poi.type);
    if (existingIdx >= 0) {
      const existing = selectedPOIs[existingIdx];
      const merged = Object.assign({}, existing, poi);
      selectedPOIs[existingIdx] = merged;
      if (poi.label && poi.label !== existing.label) {
        const labelEl = document.querySelector(`#row_${poi.type}_${poi.id} label[for="slider_${poi.id}"]`);
        if (labelEl) labelEl.textContent = `${poi.label}`;
      }
      return;
    }
    selectedPOIs.push(poi);
    const container = document.getElementById('filter-rows');
    const row = document.createElement('div');
    row.className = 'row';
    row.id = `row_${poi.type}_${poi.id}`;
    row.innerHTML = `
      <label for="slider_${poi.id}">${poi.label}</label>
      <input id="slider_${poi.id}" type="range" min="${poi.min}" max="${poi.max}" step="${poi.step}" value="${poi.def}">
      <span id="val_${poi.id}">${poi.def}</span>
      <label class="pins-toggle" title="Show pins for ${poi.label}"><input id="pins_${poi.type}_${poi.id}" type="checkbox"> Pins</label>
      <button class="remove-btn" id="rm_${poi.id}" title="Remove ${poi.label}">✕</button>
    `;
    container.appendChild(row);
    document.getElementById(`slider_${poi.id}`).addEventListener('input', debouncedUpdate);
    const pinsEl = document.getElementById(`pins_${poi.type}_${poi.id}`);
    if (pinsEl) {
      pinsEl.addEventListener('change', async (e) => {
        await togglePinsForPoi(poi, e.target.checked);
      });
    }
    document.getElementById(`rm_${poi.id}`).addEventListener('click', () => {
      // Remove from selected list and DOM
      const idx = selectedPOIs.findIndex(p => p.id === poi.id && p.type === poi.type);
      if (idx >= 0) selectedPOIs.splice(idx, 1);
      row.remove();
      removePinsForPoi(poi);
      if (poi.type === 'custom') {
        delete dAnchorCache[poi.id];
        delete customCoverageMinutes[poi.id];
      }
      updateMapFilter();
    });
    if (poi.type === 'custom') {
      const initialMinutes = normalizeMinutes(poi.def);
      showLoading('Computing drive times for custom location...');
      fetchDAnchorCustom(poi.lon, poi.lat, initialMinutes)
        .then(() => {
          console.log(`Custom D_anchor loaded for ${poi.id}, cache has ${Object.keys(dAnchorCache[poi.id] || {}).length} anchors (coverage=${customCoverageMinutes[poi.id] || 0}min)`);
          hideLoading();
          updateMapFilter();
        })
        .catch(e => {
          console.error(`Failed to fetch custom D_anchor for ${poi.id}:`, e);
          hideLoading();
          alert('Failed to compute drive times. Please try again or choose a different location.');
          updateMapFilter(); // Still update to show the POI in the list
        });
    } else if (ANCHOR_MODE && poi.type === 'category') {
      fetchDAnchor(poi.id).then(() => updateMapFilter());
    } else {
      updateMapFilter();
    }
  }

  async function fetchJSON(url) {
    console.log(`fetchJSON: requesting ${url}`);
    try {
      const resp = await fetch(url);
      console.log(`fetchJSON: got response status ${resp.status} for ${url}`);
      if (!resp.ok) {
        const text = await resp.text();
        console.error(`fetchJSON: HTTP ${resp.status} - ${text}`);
        throw new Error(`HTTP ${resp.status}: ${text}`);
      }
      const data = await resp.json();
      console.log(`fetchJSON: successfully parsed JSON for ${url}`);
      return data;
    } catch (e) {
      console.error(`fetchJSON: exception for ${url}:`, e);
      throw e;
    }
  }

  // (tile metadata probing and fallback removed)

  // (fallback selector removed)

  function initPoiSelector() {
    initCatalogSelector().catch(() => {
      const select = document.getElementById('poi-select');
      select.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Catalog unavailable';
      select.appendChild(opt);
    });
  }

  // ---------- Catalog + Anchor Mode ----------
  async function fetchDAnchor(categoryId) {
    if (dAnchorCache[categoryId]) return dAnchorCache[categoryId];
    const data = await fetchJSON(`/api/d_anchor?category=${encodeURIComponent(categoryId)}&mode=${encodeURIComponent(CURRENT_MODE)}`);
    dAnchorCache[categoryId] = data;
    return data;
  }

  async function initCatalogSelector() {
    const resp = await fetchJSON(`/api/catalog?mode=${encodeURIComponent(CURRENT_MODE)}`);
    const categories = Array.isArray(resp.categories) ? resp.categories : [];
    const brands = Array.isArray(resp.brands) ? resp.brands : [];
    const catToBrands = resp.cat_to_brands || {};
    ANCHOR_MODE = true; // always anchor-mode; D_anchor fetched on demand
    // Stash for URL parsing and labels
    window._categoriesById = new Map(categories.map(c => [String(c.id), c.label]));
    window._brandLabelById = new Map(brands.map(b => [String(b.id), b.label]));
    window._catToBrands = catToBrands;
    populateCatalogSelector(categories, brands, catToBrands);
  }

  // ---------- Custom D_anchor ----------
  function customKeyForLonLat(lon, lat) {
    const lonf = Number(lon).toFixed(5);
    const latf = Number(lat).toFixed(5);
    return `custom@${lonf},${latf}`;
  }

  function normalizeMinutes(value) {
    const raw = Number.parseInt(value, 10);
    if (!Number.isFinite(raw) || raw <= 0) return CUSTOM_MIN_MINUTES;
    const clamped = Math.max(CUSTOM_MIN_MINUTES, Math.min(CUSTOM_MAX_MINUTES, raw));
    const steps = Math.ceil(clamped / CUSTOM_FETCH_GRANULARITY);
    return steps * CUSTOM_FETCH_GRANULARITY;
  }

  async function fetchDAnchorCustom(lon, lat, minutes) {
    const key = customKeyForLonLat(lon, lat);
    const requested = normalizeMinutes(minutes ?? CUSTOM_MIN_MINUTES);
    const covered = customCoverageMinutes[key] || 0;
    if (dAnchorCache[key] && covered >= requested) {
      return dAnchorCache[key];
    }
    const params = new URLSearchParams();
    params.set('lon', String(lon));
    params.set('lat', String(lat));
    params.set('mode', CURRENT_MODE);
    params.set('cutoff', String(requested));
    params.set('overflow_cutoff', String(requested));
    const url = `/api/d_anchor_custom?${params.toString()}`;
    console.log(`Fetching custom D_anchor (${requested}min) from: ${url}`);
    const data = await fetchJSON(url);
    dAnchorCache[key] = data;
    customCoverageMinutes[key] = requested;
    return data;
  }

  // ---------- Places Autocomplete (Custom Location) ----------
  function generatePlacesSessionToken() {
    if (window.crypto && window.crypto.randomUUID) {
      return window.crypto.randomUUID();
    }
    return `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }

  function locationBiasForPlacesAutocomplete() {
    const bbox = currentBboxParam();
    if (bbox) return bbox;
    try {
      const center = map.getCenter();
      if (center) return `${center.lng},${center.lat}`;
    } catch (e) {}
    return null;
  }

  function setPlaceSearchStatus(message, tone = '') {
    if (!placeSearchStatusEl) return;
    placeSearchStatusEl.textContent = message || '';
    placeSearchStatusEl.className = 'search-status';
    if (tone) placeSearchStatusEl.classList.add(tone);
  }

  function resetPlacesSuggestions(options = {}) {
    placeSearchSuggestions = [];
    placeSearchActiveIndex = -1;
    if (placeSearchResultsEl) {
      placeSearchResultsEl.innerHTML = '';
      placeSearchResultsEl.classList.remove('open');
    }
    if (placeSearchInputEl) {
      placeSearchInputEl.setAttribute('aria-expanded', 'false');
      placeSearchInputEl.removeAttribute('aria-activedescendant');
      placeSearchInputEl.removeAttribute('aria-busy');
    }
    if (options.clearStatus) {
      setPlaceSearchStatus('', '');
    }
  }

  function updatePlaceSearchHighlight(newIndex) {
    const items = placeSearchResultsEl ? placeSearchResultsEl.querySelectorAll('.search-item') : [];
    if (!items.length) {
      placeSearchActiveIndex = -1;
      if (placeSearchInputEl) placeSearchInputEl.removeAttribute('aria-activedescendant');
      return;
    }
    let idx = typeof newIndex === 'number' ? newIndex : placeSearchActiveIndex;
    if (idx < 0 || idx >= items.length) {
      idx = -1;
    }
    placeSearchActiveIndex = idx;
    items.forEach((el, i) => {
      if (i === placeSearchActiveIndex) {
        el.classList.add('active');
        el.setAttribute('aria-selected', 'true');
        if (placeSearchInputEl) {
          placeSearchInputEl.setAttribute('aria-activedescendant', el.id || '');
        }
        el.scrollIntoView({ block: 'nearest' });
      } else {
        el.classList.remove('active');
        el.setAttribute('aria-selected', 'false');
      }
    });
    if (placeSearchActiveIndex === -1 && placeSearchInputEl) {
      placeSearchInputEl.removeAttribute('aria-activedescendant');
    }
  }

  function renderPlaceSearchSuggestions() {
    if (!placeSearchResultsEl) return;
    placeSearchResultsEl.innerHTML = '';
    if (!placeSearchSuggestions.length) {
      placeSearchResultsEl.classList.remove('open');
      if (placeSearchInputEl) placeSearchInputEl.setAttribute('aria-expanded', 'false');
      return;
    }
    placeSearchSuggestions.forEach((suggestion, index) => {
      const item = document.createElement('div');
      item.className = 'search-item';
      item.id = `place-search-item-${index}`;
      item.setAttribute('role', 'option');
      const primary = document.createElement('div');
      primary.className = 'search-primary';
      primary.textContent = suggestion.label || suggestion.sublabel || 'Unnamed place';
      item.appendChild(primary);
      if (suggestion.sublabel && suggestion.sublabel !== suggestion.label) {
        const secondary = document.createElement('div');
        secondary.className = 'search-secondary';
        secondary.textContent = suggestion.sublabel;
        item.appendChild(secondary);
      }
      item.addEventListener('mousedown', (event) => {
        event.preventDefault();
        selectPlaceSuggestion(index);
      });
      placeSearchResultsEl.appendChild(item);
    });
    placeSearchResultsEl.classList.add('open');
    if (placeSearchInputEl) placeSearchInputEl.setAttribute('aria-expanded', 'true');
    updatePlaceSearchHighlight(-1);
  }

  async function requestPlacesAutocomplete(value) {
    const query = String(value || '').trim();
    if (query.length < PLACE_AUTOCOMPLETE_MIN_CHARS) {
      resetPlacesSuggestions();
      return;
    }
    if (!placeSearchSessionToken) {
      placeSearchSessionToken = generatePlacesSessionToken();
    }
    if (placeSearchAbortController) {
      placeSearchAbortController.abort();
    }
    placeSearchAbortController = new AbortController();
    if (placeSearchInputEl) placeSearchInputEl.setAttribute('aria-busy', 'true');
    setPlaceSearchStatus('Searching…', 'info');
    const params = new URLSearchParams();
    params.set('q', query);
    params.set('session', placeSearchSessionToken);
    params.set('limit', String(PLACE_SUGGESTION_LIMIT));
    const bias = locationBiasForPlacesAutocomplete();
    if (bias) params.set('locationBias', bias);
    try {
      const resp = await fetch(`/api/places/autocomplete?${params.toString()}`, { signal: placeSearchAbortController.signal });
      if (!resp.ok) {
        let detail = `HTTP ${resp.status}`;
        try {
          const errJson = await resp.json();
          if (errJson && errJson.detail) detail = errJson.detail;
        } catch (e) {}
        throw new Error(detail);
      }
      const data = await resp.json();
      const results = Array.isArray(data.results) ? data.results : [];
      placeSearchSuggestions = results.slice(0, PLACE_SUGGESTION_LIMIT);
      renderPlaceSearchSuggestions();
      if (placeSearchSuggestions.length === 0) {
        setPlaceSearchStatus('No matches found.', 'info');
      } else {
        setPlaceSearchStatus('', '');
      }
    } catch (error) {
      if (error && error.name === 'AbortError') return;
      console.error('Places autocomplete failed', error);
      setPlaceSearchStatus('Unable to fetch suggestions. Please try again.', 'error');
      resetPlacesSuggestions();
    } finally {
      if (placeSearchInputEl) placeSearchInputEl.removeAttribute('aria-busy');
      placeSearchAbortController = null;
    }
  }

  function selectPlaceSuggestion(index) {
    if (index == null) index = placeSearchActiveIndex;
    if (index == null || index < 0) index = placeSearchSuggestions.length === 1 ? 0 : index;
    const suggestion = placeSearchSuggestions[index];
    if (!suggestion) return;
    if (placeSearchAbortController) {
      placeSearchAbortController.abort();
      placeSearchAbortController = null;
    }
    if (placeSearchInputEl) {
      const value = suggestion.label || suggestion.sublabel || '';
      placeSearchInputEl.value = value;
      placeSearchInputEl.setAttribute('aria-busy', 'true');
    }
    resetPlacesSuggestions();
    setPlaceSearchStatus('Fetching location…', 'info');
    fetchPlaceDetails(suggestion);
  }

  async function fetchPlaceDetails(suggestion) {
    if (!suggestion || !suggestion.id) {
      setPlaceSearchStatus('Missing place identifier.', 'error');
      if (placeSearchInputEl) placeSearchInputEl.removeAttribute('aria-busy');
      return;
    }
    if (!placeSearchSessionToken) {
      placeSearchSessionToken = generatePlacesSessionToken();
    }
    const params = new URLSearchParams();
    params.set('id', suggestion.id);
    params.set('session', placeSearchSessionToken);
    try {
      const resp = await fetch(`/api/places/details?${params.toString()}`);
      if (!resp.ok) {
        let detail = `HTTP ${resp.status}`;
        try {
          const errJson = await resp.json();
          if (errJson && errJson.detail) detail = errJson.detail;
        } catch (e) {}
        throw new Error(detail);
      }
      const data = await resp.json();
      const result = data && data.result ? data.result : null;
      if (!result || typeof result.lon !== 'number' || typeof result.lat !== 'number') {
        throw new Error('Missing coordinates');
      }
      const lon = result.lon;
      const lat = result.lat;
      const label = result.label || suggestion.label || 'Custom Location';
      const sublabel = result.sublabel || suggestion.sublabel || '';
      try {
        const targetZoom = Math.max(map.getZoom(), 13);
        map.easeTo({ center: [lon, lat], zoom: targetZoom, duration: 800 });
      } catch (e) {}
      if (!placeSearchMarker) {
        placeSearchMarker = new maplibregl.Marker({ color: '#ef4444' });
      }
      placeSearchMarker.setLngLat([lon, lat]).addTo(map);
      const poi = { type: 'custom', id: customKeyForLonLat(lon, lat), label, lon, lat, def: 30, min: 5, max: 240, step: 5 };
      addPOIRow(poi);
      if (placeSearchInputEl) {
        placeSearchInputEl.value = label;
        placeSearchInputEl.blur();
        placeSearchInputEl.removeAttribute('aria-busy');
      }
      placeSearchSessionToken = null;
      if (sublabel) {
        setPlaceSearchStatus(sublabel, '');
      } else {
        setPlaceSearchStatus('', '');
      }
    } catch (error) {
      console.error('Place details failed', error);
      setPlaceSearchStatus(error && error.message ? error.message : 'Unable to fetch place details.', 'error');
      if (placeSearchInputEl) placeSearchInputEl.removeAttribute('aria-busy');
    }
  }

  function initializePlaceSearch() {
    placeSearchInputEl = document.getElementById('place-search-input');
    placeSearchResultsEl = document.getElementById('place-search-results');
    placeSearchStatusEl = document.getElementById('place-search-status');
    if (!placeSearchInputEl) return;
    const scheduleAutocomplete = debounce((value) => {
      requestPlacesAutocomplete(value);
    }, PLACE_AUTOCOMPLETE_DEBOUNCE_MS);
    placeSearchInputEl.addEventListener('focus', () => {
      placeSearchSessionToken = generatePlacesSessionToken();
      setPlaceSearchStatus('Type at least two characters to search.', 'info');
    });
    placeSearchInputEl.addEventListener('input', (event) => {
      const value = event.target.value || '';
      if (value.trim().length < PLACE_AUTOCOMPLETE_MIN_CHARS) {
        if (placeSearchAbortController) {
          placeSearchAbortController.abort();
          placeSearchAbortController = null;
        }
        resetPlacesSuggestions();
        if (value.trim().length === 0) {
          setPlaceSearchStatus('', '');
        } else {
          setPlaceSearchStatus('Keep typing…', 'info');
        }
        return;
      }
      scheduleAutocomplete(value);
    });
    placeSearchInputEl.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowDown') {
        if (!placeSearchSuggestions.length) return;
        event.preventDefault();
        const next = placeSearchActiveIndex + 1;
        const wrapped = next >= placeSearchSuggestions.length ? 0 : next;
        placeSearchActiveIndex = wrapped;
        updatePlaceSearchHighlight(placeSearchActiveIndex);
        return;
      }
      if (event.key === 'ArrowUp') {
        if (!placeSearchSuggestions.length) return;
        event.preventDefault();
        const prev = placeSearchActiveIndex <= 0 ? placeSearchSuggestions.length - 1 : placeSearchActiveIndex - 1;
        placeSearchActiveIndex = prev;
        updatePlaceSearchHighlight(placeSearchActiveIndex);
        return;
      }
      if (event.key === 'Enter') {
        if (placeSearchSuggestions.length > 0) {
          event.preventDefault();
          const index = placeSearchActiveIndex >= 0 ? placeSearchActiveIndex : 0;
          selectPlaceSuggestion(index);
        }
      }
      if (event.key === 'Escape') {
        resetPlacesSuggestions({ clearStatus: true });
      }
    });
    placeSearchInputEl.addEventListener('blur', () => {
      setTimeout(() => {
        if (document.activeElement !== placeSearchInputEl) {
          resetPlacesSuggestions();
          placeSearchSessionToken = null;
        }
      }, 120);
    });
    document.addEventListener('click', (event) => {
      if (!placeSearchInputEl) return;
      if (event.target === placeSearchInputEl) return;
      if (placeSearchResultsEl && placeSearchResultsEl.contains(event.target)) return;
      resetPlacesSuggestions();
    });
  }

  // (min-column fallback removed; GPU composition only)

  function populateCatalogSelector(categories, brands, catToBrands) {
    const select = document.getElementById('poi-select');
    select.innerHTML = '';
    const brandMap = new Map(brands.map(b => [String(b.id), b.label]));
    // Group categories by label to avoid repeated labels (e.g., multiple "Restaurant")
    const groups = new Map(); // label -> { label, ids:Set<string>, brandIds:Set<string> }
    categories.forEach(cat => {
      const label = String(cat.label);
      const scid = String(cat.id);
      const g = groups.get(label) || { label, ids: new Set(), brandIds: new Set() };
      g.ids.add(scid);
      const bidList = catToBrands[String(cat.id)] || [];
      bidList.forEach(bid => g.brandIds.add(String(bid)));
      groups.set(label, g);
    });

    // Stash mapping of joined-ids -> label for URL parsing
    window._groupLabelByIds = new Map();

    const addedBrands = new Set();
    Array.from(groups.values()).sort((a,b) => a.label.localeCompare(b.label)).forEach(g => {
      const og = document.createElement('optgroup');
      og.label = g.label;
      // Category-level selection (joined ids)
      const joined = Array.from(g.ids).sort().join(',');
      const optAll = document.createElement('option');
      optAll.value = `cat:${joined}`;
      optAll.textContent = g.label;
      og.appendChild(optAll);
      window._groupLabelByIds.set(joined, g.label);
      // Brand list (union across grouped categories)
      Array.from(g.brandIds).sort().forEach(bid => {
        const opt = document.createElement('option');
        opt.value = `brand:${bid}`;
        opt.textContent = brandMap.get(bid) || bid;
        og.appendChild(opt);
        addedBrands.add(bid);
      });
      select.appendChild(og);
    });

    // Add any extra brands (no category mapping) under Other Brands
    const extra = brands.filter(b => !addedBrands.has(String(b.id)));
    if (extra.length) {
      const og = document.createElement('optgroup');
      og.label = 'Other Brands';
      extra.forEach(b => {
        const opt = document.createElement('option');
        opt.value = `brand:${b.id}`;
        opt.textContent = b.label;
        og.appendChild(opt);
      });
      select.appendChild(og);
    }
    const addBtn = document.getElementById('add-poi');
    addBtn.onclick = async () => {
      const v = select.value || '';
      if (v.startsWith('cat:')) {
        const id = v.slice(4); // may be comma-joined ids
        const label = (window._groupLabelByIds && window._groupLabelByIds.get(String(id))) || (window._categoriesById && window._categoriesById.get(String(id))) || `Category ${id}`;
        const ids = String(id).split(',').filter(Boolean);
        addPOIRow({ type: 'category', id, ids, label, def: 30, min: 5, max: 240, step: 5 });
        await ensureCombinedDAnchor(id, ids);
        updateMapFilter();
      } else if (v.startsWith('brand:')) {
        const id = v.slice(6);
        const label = brandMap.get(id) || (window._brandLabelById && window._brandLabelById.get(id)) || id;
        addPOIRow({ type: 'brand', id, label, def: 30, min: 5, max: 240, step: 5 });
        try { await fetchDAnchorBrand(id); } catch (e) {}
        updateMapFilter();
      }
    };
  }

  async function ensureCombinedDAnchor(key, ids) {
    // Ensure dAnchorCache[key] contains per-anchor seconds = min over ids' maps
    if (!Array.isArray(ids)) ids = String(key).split(',').filter(Boolean);
    // Fetch missing pieces
    await Promise.all(ids.map((cid) => dAnchorCache[cid] ? Promise.resolve(dAnchorCache[cid]) : fetchDAnchor(cid)));
    const combined = {};
    ids.forEach((cid) => {
      const m = dAnchorCache[cid] || {};
      for (const [aid, sec] of Object.entries(m)) {
        const v = combined[aid];
        combined[aid] = (v == null) ? sec : Math.min(v, sec);
      }
    });
    dAnchorCache[key] = combined;
    return combined;
  }

  async function fetchDAnchorBrand(brandId) {
    if (dAnchorCache[brandId]) return dAnchorCache[brandId];
    const data = await fetchJSON(`/api/d_anchor_brand?brand=${encodeURIComponent(brandId)}&mode=${encodeURIComponent(CURRENT_MODE)}`);
    dAnchorCache[brandId] = data;
    return data;
  }

  // ---------- Pins (POI locations) ----------
  function rowKeyForPoi(poi) {
    return `${poi.type}_${poi.id}`;
  }

  function getBrandIdsForPoi(poi) {
    if (poi.type === 'brand') return [String(poi.id)];
    const mapping = window._catToBrands || {};
    const ids = Array.isArray(poi.ids) ? poi.ids : String(poi.id).split(',').filter(Boolean);
    const out = new Set();
    ids.forEach((cid) => {
      const arr = mapping[String(cid)] || [];
      arr.forEach((b) => out.add(String(b)));
    });
    return Array.from(out);
  }

  function currentBboxParam() {
    try {
      const b = map.getBounds();
      return `${b.getWest()},${b.getSouth()},${b.getEast()},${b.getNorth()}`;
    } catch (e) {
      return null;
    }
  }

  async function fetchPinsGeoJSON(brands) {
    const params = new URLSearchParams();
    params.set('brands', brands.join(','));
    const bbox = currentBboxParam();
    if (bbox) params.set('bbox', bbox);
    return await fetchJSON(`/api/poi_points?${params.toString()}`);
  }

  function removePinsForPoi(poi) {
    const key = rowKeyForPoi(poi);
    const rec = activePins[key];
    if (!rec) return;
    // Remove layers first, then source
    try { if (map.getLayer(rec.layerIds[2])) map.removeLayer(rec.layerIds[2]); } catch (e) {}
    try { if (map.getLayer(rec.layerIds[1])) map.removeLayer(rec.layerIds[1]); } catch (e) {}
    try { if (map.getLayer(rec.layerIds[0])) map.removeLayer(rec.layerIds[0]); } catch (e) {}
    try { if (map.getSource(rec.sourceId)) map.removeSource(rec.sourceId); } catch (e) {}
    delete activePins[key];
  }

  async function togglePinsForPoi(poi, checked) {
    const key = rowKeyForPoi(poi);
    if (!checked) {
      removePinsForPoi(poi);
      return;
    }
    if (poi.type === 'custom') {
      // Add a single-point source + simple circle layer
      const sourceId = `pins_${key}`;
      const layerId = `pins_${key}_point`;
      try { if (map.getLayer(layerId)) map.removeLayer(layerId); } catch (e) {}
      try { if (map.getSource(sourceId)) map.removeSource(sourceId); } catch (e) {}
      const geo = { type: 'FeatureCollection', features: [ { type: 'Feature', geometry: { type: 'Point', coordinates: [poi.lon, poi.lat] }, properties: {} } ] };
      map.addSource(sourceId, { type: 'geojson', data: geo });
      map.addLayer({ id: layerId, type: 'circle', source: sourceId, paint: { 'circle-radius': 6, 'circle-color': '#ef4444', 'circle-stroke-color': '#ffffff', 'circle-stroke-width': 1.2 } });
      activePins[key] = { brands: [], sourceId, layerIds: [layerId] };
      return;
    }
    const brands = getBrandIdsForPoi(poi);
    if (!brands || brands.length === 0) {
      // No known brands under this selection
      return;
    }
    const geo = await fetchPinsGeoJSON(brands);
    const sourceId = `pins_${key}`;
    const unclusterId = `pins_${key}_points`;
    const clusterId = `pins_${key}_clusters`;
    const clusterCountId = `pins_${key}_count`;
    // Clean any stale layers/sources
    try { if (map.getLayer(clusterCountId)) map.removeLayer(clusterCountId); } catch(e) {}
    try { if (map.getLayer(clusterId)) map.removeLayer(clusterId); } catch(e) {}
    try { if (map.getLayer(unclusterId)) map.removeLayer(unclusterId); } catch(e) {}
    try { if (map.getSource(sourceId)) map.removeSource(sourceId); } catch(e) {}

    map.addSource(sourceId, { type: 'geojson', data: geo, cluster: true, clusterRadius: 40, clusterMaxZoom: 14 });
    // Unclustered points
    map.addLayer({
      id: unclusterId,
      type: 'circle',
      source: sourceId,
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, 2.5, 10, 4, 14, 6],
        'circle-color': '#8b5cf6',
        'circle-opacity': 0.85,
        'circle-stroke-color': '#ffffff',
        'circle-stroke-width': 0.8
      }
    });
    // Cluster circles
    map.addLayer({
      id: clusterId,
      type: 'circle',
      source: sourceId,
      filter: ['has', 'point_count'],
      paint: {
        'circle-radius': ['step', ['get', 'point_count'], 12, 25, 16, 50, 20],
        'circle-color': '#8b5cf6',
        'circle-opacity': 0.6
      }
    });
    // Cluster counts
    map.addLayer({
      id: clusterCountId,
      type: 'symbol',
      source: sourceId,
      filter: ['has', 'point_count'],
      layout: {
        'text-field': ['get', 'point_count_abbreviated'],
        'text-size': 12
      },
      paint: { 'text-color': '#ffffff' }
    });

    activePins[key] = { brands, sourceId, layerIds: [unclusterId, clusterId, clusterCountId] };
  }

  async function refreshActivePins() {
    const keys = Object.keys(activePins);
    if (!keys.length) return;
    for (const key of keys) {
      const rec = activePins[key];
      try {
        const geo = await fetchPinsGeoJSON(rec.brands);
        const src = map.getSource(rec.sourceId);
        if (src && src.setData) src.setData(geo);
      } catch (e) {
        // ignore transient errors
      }
    }
  }

  // ---------- Share URL ----------
  document.getElementById('share').addEventListener('click', () => {
    const params = new URLSearchParams();
    // Mode
    params.set('mode', CURRENT_MODE);
    // Categories
    const cats = selectedPOIs.filter(p => p.type === 'category').map(p => {
      const slider = document.getElementById('slider_' + p.id);
      const v = slider ? slider.value : p.def;
      return `${encodeURIComponent(p.id)}:${v}`;
    });
    if (cats.length) params.set('cat', cats.join(','));
    // Brands
    const brands = selectedPOIs.filter(p => p.type === 'brand').map(p => {
      const slider = document.getElementById('slider_' + p.id);
      const v = slider ? slider.value : p.def;
      return `${encodeURIComponent(p.id)}:${v}`;
    });
    if (brands.length) params.set('brand', brands.join(','));
    // Custom
    const customs = selectedPOIs.filter(p => p.type === 'custom').map(p => {
      const slider = document.getElementById('slider_' + p.id);
      const v = slider ? slider.value : p.def;
      const lon = Number(p.lon).toFixed(5);
      const lat = Number(p.lat).toFixed(5);
      return `${encodeURIComponent(lon + '|' + lat)}:${v}`;
    });
    if (customs.length) params.set('custom', customs.join(','));
    const url = new URL(window.location.href);
    url.search = params.toString();
    navigator.clipboard.writeText(url.toString()).then(() => {
      const btn = document.getElementById('share');
      const originalText = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(() => (btn.textContent = originalText), 1500);
    });
  });

  async function applyUrlParams() {
    const params = new URLSearchParams(window.location.search);
    // Mode
    const m = params.get('mode');
    if (m === 'walk' || m === 'drive') {
      CURRENT_MODE = m;
      document.getElementById('mode-select').value = m;
      // Toggle layers now if already loaded
      try {
        if (ANCHOR_MODE) {
          map.setLayoutProperty('layer_r8_drive', 'visibility', m === 'drive' ? 'visible' : 'none');
          map.setLayoutProperty('layer_r8_walk', 'visibility', m === 'walk' ? 'visible' : 'none');
          map.setLayoutProperty('layer_r7_drive', 'visibility', 'none');
        }
      } catch (e) {}
    }
    // Categories
    if (params.has('cat')) {
      const pairs = params.get('cat').split(',');
      for (const item of pairs) {
        const [idEnc, val] = item.split(':');
        const id = decodeURIComponent(idEnc);
        const ids = String(id).split(',').filter(Boolean);
        const label = (window._groupLabelByIds && window._groupLabelByIds.get(String(id))) || (ids.length === 1 ? (window._categoriesById && window._categoriesById.get(String(id))) : null) || `Category ${id}`;
        addPOIRow({ type: 'category', id, ids, label, def: 30, min: 5, max: 240, step: 5 });
        const slider = document.getElementById(`slider_${id}`);
        if (slider && val) slider.value = val;
        await ensureCombinedDAnchor(id, ids);
      }
    }
    // Brands
    if (params.has('brand')) {
      const pairs = params.get('brand').split(',');
      for (const item of pairs) {
        const [idEnc, val] = item.split(':');
        const id = decodeURIComponent(idEnc);
        const label = (window._brandLabelById && window._brandLabelById.get(id)) || id.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        addPOIRow({ type: 'brand', id, label, def: 30, min: 5, max: 240, step: 5 });
        const slider = document.getElementById(`slider_${id}`);
        if (slider && val) slider.value = val;
        try { await fetchDAnchorBrand(id); } catch (e) {}
      }
    }
    // Custom
    if (params.has('custom')) {
      const pairs = params.get('custom').split(',');
      for (const item of pairs) {
        const [coordEnc, val] = item.split(':');
        const coord = decodeURIComponent(coordEnc);
        const [lonS, latS] = coord.split('|');
        const lon = parseFloat(lonS);
        const lat = parseFloat(latS);
        const id = customKeyForLonLat(lon, lat);
        addPOIRow({ type: 'custom', id, label: 'Custom Location', lon, lat, def: 30, min: 5, max: 240, step: 5 });
        const slider = document.getElementById(`slider_${id}`);
        if (slider && val) slider.value = val;
        try { await fetchDAnchorCustom(lon, lat); } catch (e) {}
      }
    }
    if (selectedPOIs.length === 0) {
      // Default: none preselected; user picks from dropdown
    }
  }

  // ---------- Mode Toggle ----------
  function setLayerVisibility(id, vis) {
    try {
      if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
    } catch (e) {}
  }

  function setMode(mode) {
    if (CURRENT_MODE === mode) return;
    CURRENT_MODE = mode;
    // Toggle layers
    if (ANCHOR_MODE) {
      setLayerVisibility('layer_r7_drive', 'none');
      setLayerVisibility('layer_r8_drive', mode === 'drive' ? 'visible' : 'none');
      setLayerVisibility('layer_r8_walk', mode === 'walk' ? 'visible' : 'none');
    }
    // Reset caches and refetch D_anchor for selected categories, brands, and custom locations
    for (const k in dAnchorCache) delete dAnchorCache[k];
    for (const k in customCoverageMinutes) delete customCoverageMinutes[k];
    if (ANCHOR_MODE) {
      initCatalogSelector();
      const loaders = selectedPOIs.map(p => {
        if (p.type === 'category') {
          return fetchDAnchor(p.id);
        } else if (p.type === 'brand') {
          return fetchDAnchorBrand(p.id);
        } else if (p.type === 'custom') {
          return fetchDAnchorCustom(p.lon, p.lat);
        }
        return Promise.resolve();
      });
      Promise.all(loaders).then(() => updateMapFilter());
    } else {
      updateMapFilter();
    }
    // No tile-column fallback; catalog remains the source of truth
  }

  document.getElementById('mode-select').addEventListener('change', (e) => {
    setMode(e.target.value);
  });

  // ---------- Map Events ----------
  map.on('load', async () => {
    initPoiSelector();
    initializePlaceSearch();
    // Wait a tick for metadata to resolve and selector to populate (anchor vs min mode)
    setTimeout(async () => {
      await applyUrlParams();
      updateMapFilter();
    }, 50);

    map.on('mousemove', (e) => {
      const layers = ['layer_r8_drive', 'layer_r8_walk', 'layer_r7_drive'];
      const features = map.queryRenderedFeatures(e.point, { layers });
      if (features && features.length > 0) {
        const f = features[0];
        if (ANCHOR_MODE) {
          // Build hover details for selected categories and brands
          const props = f.properties || {};
          let html = '';
          selectedPOIs.forEach((p) => {
            if (p.type === 'category') {
              const UNREACH = 65535;
              let minsSec = UNREACH;
              for (let i = 0; i < MAX_K; i++) {
                const aSec = (props[`a${i}_s`] ?? UNREACH);
                const aid = String(props[`a${i}_id`] ?? '');
                const catMap = dAnchorCache[p.id] || {};
                const catSec = (aid && catMap[aid] != null) ? catMap[aid] : UNREACH;
                const tot = aSec + catSec;
                if (tot < minsSec) minsSec = tot;
              }
              const mins = (minsSec >= UNREACH) ? 'N/A' : Math.ceil(minsSec / 60) + ' min';
              html += `<div class="kv"><span>${p.label}</span><span>${mins}</span></div>`;
            } else if (p.type === 'brand') {
              const UNREACH = 65535;
              let minsSec = UNREACH;
              for (let i = 0; i < MAX_K; i++) {
                const aSec = (props[`a${i}_s`] ?? UNREACH);
                const aid = String(props[`a${i}_id`] ?? '');
                const brandMap = dAnchorCache[p.id] || {};
                const bSec = (aid && brandMap[aid] != null) ? brandMap[aid] : UNREACH;
                const tot = aSec + bSec;
                if (tot < minsSec) minsSec = tot;
              }
              const mins = (minsSec >= UNREACH) ? 'N/A' : Math.ceil(minsSec / 60) + ' min';
              html += `<div class="kv"><span>${p.label}</span><span>${mins}</span></div>`;
            } else if (p.type === 'custom') {
              const UNREACH = 65535;
              let minsSec = UNREACH;
              for (let i = 0; i < MAX_K; i++) {
                const aSec = (props[`a${i}_s`] ?? UNREACH);
                const aid = String(props[`a${i}_id`] ?? '');
                const customMap = dAnchorCache[p.id] || {};
                const cSec = (aid && customMap[aid] != null) ? customMap[aid] : UNREACH;
                const tot = aSec + cSec;
                if (tot < minsSec) minsSec = tot;
              }
              const mins = (minsSec >= UNREACH) ? 'N/A' : Math.ceil(minsSec / 60) + ' min';
              html += `<div class="kv"><span>${p.label}</span><span>${mins}</span></div>`;
            }
          });
          document.getElementById('hover-content').innerHTML = html || '<span class="muted">Select a category, brand, or custom location</span>';
        } else {
          updateHoverBox(f);
        }
      } else {
        updateHoverBox(null);
      }
    });
    map.on('moveend', refreshActivePins);

    // Enable map-pick for custom location
    document.getElementById('add-custom').addEventListener('click', () => {
      PICKING_CUSTOM = true;
      const btn = document.getElementById('add-custom');
      const original = btn.textContent;
      btn.textContent = 'Click map…';
      const once = async (e) => {
        if (!PICKING_CUSTOM) return;
        PICKING_CUSTOM = false;
        btn.textContent = original;
        try {
          const lngLat = e.lngLat || (e.point && map.unproject(e.point));
          const lon = lngLat.lng;
          const lat = lngLat.lat;
          const id = customKeyForLonLat(lon, lat);
          addPOIRow({ type: 'custom', id, label: 'Custom Location', lon, lat, def: 30, min: 5, max: 240, step: 5 });
          // Note: addPOIRow will call fetchDAnchorCustom and show loading indicator
        } finally {
          map.off('click', once);
        }
      };
      map.once('click', once);
    });
  });

</script>
</body>
</html>
